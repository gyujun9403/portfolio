# 1. 토이 프로젝트 개요

## 1.1 프로젝트 개요
<img src=".\images\FreeMove.gif">

서버 및 클라의 동기화 기법이 동기화의 필요성에 대해 그래픽 및 수치적으로 확인하고 분석하고자 수행하였다. 해당 토이 프로젝트에서 중심적으로 파악할 내용은 다음과 같다.

1. 동기화가 전혀 없을 때 문제를 그래픽 및 데이터로 확인하고 분석
2. 이후 데드레커닝과 조작 지연 동기화를 각각 적용했을 때의 성능 향상을 그래픽 및 데이터로 분석

## 1.2 사용 기술스택

서버 : Linux환경 C++서버(epoll사용). 코드

클라 : 유니티. 코드

# 2. 기본 조작 및 동작 방식
<img src=".\images\CS.png"  width="350" height="300"/>


키보드 방향키를 통해 송신 측을 조작하고, 조작 후의 데이터를 소켓 통신을 통해 전달한다. 이때 각 송수신 통신 지연을 설정하고, 그에 따른 시점 차이를 관찰한다.

- **데이터** : 위치 및 속도 데이터를 주고 받는다.
- **송신측** : 방향키로 캐릭터를 조작하고, 상태값을 서버로 송신
    
    통신환경이 괜찮다 가정하여 지연시간 15msec(→ Ping 30msec)적용.
    
- **서버** : 송신측으로부터 데이터를 받고, 값을 갱신.
- **수신측** : 다른 유저가 보는 내 캐릭터. 통신 딜레이로 인해 과거의 위치.
    
    통신환경이 그닥 좋지 않다고 가정하여 지연시간 45msec(→ Ping 90msec)적용.

이때 테스트 동작 방식은 x는 sin(t), y는 cos(t) 함수를 적용. 한 프레임당 t값을 증가시켜 원형으로 돌게 한다. 
<details>
<summary>(추가) Localhost간 통신 딜레이 설정과정</summary>
현재 테스트 환경은 localhost 연결이므로, 지연 시간이 거의 없다. 따라서 각 데이터마다 전송 시간을 설정하여, 그 시간 이후에 보내는 방식으로 지연 시간을 구현한다.
    
    - 보낼 데이터를 queueing하고 전송 예약 시간을 기입 후 해당 시간에 전송.
    - 실제 게임에서는 게임 시작 전 로딩 도중 클라와 몇 번의 통신을 통해 평균치를 구하던가 하는 방식으로 정할 수 있을 것이다.
    
    위 GIF이미지에서 왼쪽 상단의 Send Delay값이 보내는 지연시간, Recv Delay값은 받는 지연시간이다. 클라이언트가 서로 다르다고 가정하면 보내는 쪽은 핑이 30msec, 받는쪽의 핑은 90msec인 상황이다.
</details>

# 3. 아무런 동기화 기법이 없을 때
<img src=".\images\NotDeadReckoning.gif">
<!--![NotDeadReckoning.gif](.\images\NotDeadReckoning.gif)-->
<img src=".\images\plot_NRND.png">
<!--![plot_NRND.png](images\plot_NRND.png)-->

그래프에서 This는 컨트롤 캐릭터(자주색), Server는 서버측 데이터(녹색), Other는 다른 클라 시점(파란색)이다.

일단 gif에서도 툭툭 끊기는 듯하게 보이며, 그래프에서는 이를 더 직접적으로 확인 가능하다. 간단하게 분석하면 다음과 같다.

- 수신 측의 경우, 받은 위치를 다음 데이터가 오기 전까지 그대로 유지한다. 따라서 데이터를 받은 시점 보다 더 이후에 피팅 한 그래프가 생성되었다.
- 맨 처음 수신한 지연 시간은 45msec이더라도, 유저가 체감하는 지연시간은 평균 74msec에서 길게는 90msec까지 늘어날 수 있다는 것이다.

# 4. 동기화 적용 및 결과 비교

우선 데드레커닝을 통해 동작을 매끄럽게 하고, 이후 조작 지연 동기화를 적용하여 성능의 차이를 비교해 본다.
 - 데드레커닝 : 보간법과 달리 지연시간을 증가시키지 않으므로 적용. 다만 오차에 따른 튐 현상은 주의할 필요가 있을 것.
 - 조작 지연 적용 기법 : 이론상 서버 및 클라들을 시간 차이 없이 동기화할 수 있는 동기화 기법이라 판단하여 적용. 약간의 동작 딜레이가 문제가 되어 Frame Rate가 낮아질 수 있으나, 데드레커닝과 조합 시 Frame Rate도 확보할 수 있을 것이라 판단 하였다.
</br>\([참고문서](https://m.blog.naver.com/PostView.naver?blogId=linegamedev&logNo=221061964789&targetKeyword=&targetRecommendationCode=1)의 Fixed Time Bucket Synchronization라고 표현된 동기화를 변형하여 적용 \)

## 4.1 데드레커닝 적용시
<img src=".\images\DeadReckoning.gif">
<!--![DeadReckoning.gif](images\DeadReckoning.gif)-->
<img src=".\images\plot_RND.png">
<!--![Untitled](images\plot_RND.png)-->

GIF파일만 봐도 이전보다 더 매끄럽게 움직이며, 로그 데이터 형태도 원본과 근사하게 찍힌다.

- 통신 사이 동작을 예측하므로, 통신 대기 중에도 수신측은 부드럽게 이동한다.
- 이전 데이터와 달리, 수신 딜레이가 설정값인 45msec에 근접한다.
(같지 않은 이유는 localhost의 전송 지연 및 서버의 IO시간 등의 요소일 것이다).
- `1.영역`처럼 속도 변화가 적은 부분의 경우 오차가 적다.
- `2.영역`처럼 급격한 속도 변화 발생시, 오차가 커질 수 있다. </br>하지만 동작 애니메이션을 등을 통해 가속도가 적용되는 게임은, 오차를 감출 수 있을 것이다.

## 4.2 조작 지연 동기화 적용

### 4.2.1 조작 지연 동기화 없을시
<img src=".\images\timePlot1.png">
<!--![Untitled](images\timePlot1.png)-->

각 조작 및 통신 데이터들은 바로 적용되어 위와 같이 동작한다. 이 경우 송신측과 수신측과 딜레이는 60msec까지 넘어가, 게임 플레이에 악영향을 미칠것이다.

### 4.2.2 이론적인 조작 지연 동기화
<img src=".\images\timePlot2.png">
<!--![Untitled](images\timePlot2.png)-->

 조작 지연 동기화의 주요 골자는 수신 측이 데이터를 받을 시간을 예상해서, 그 시간까지 송신 측 및 서버가 대기 후 그 데이터를 적용시킨다. 이를 통해 송수신 간 통신 딜레이에 의한 정보 차이를 \(이론상\)없앨 수 있다. </br>
 하지만, 다만, 지연시간을 그대로 적용하는 경우 송신 측 조작감에 큰 영향을 미칠 수 있으므로 송수신 딜레이 값을 곧이 곧대로 적용시켜선 안된다고 판단했다.

### 4.2.3 조작감을 고려한 조작 지연 동기화
<img src=".\images\timePlot3.png">
<!--![Untitled](images\timePlot3.png)-->

  조작감을 고려하여 송신 측 조작 대기시간에 상한 값을 정한다. 평균적으로 ping 값이 50msec 이하일때 쾌적한 게임 환경이 된다고 한다. 거기다 사람에 따라 더 민감할 수 있으므로 이보다 더 작은 값인 30msec을 최대 지연 시간으로 정했다. 이 값은 게임의 특성에 따라 더 줄이거나 늘릴 수 있을 것이다.

- 송신 측 지연 : `min(송신지연 + 수신지연, 30msec)`
- 서버 측 지연 : `max((송신최종지연 - 송신지연 + 수신시연) / 2, 0msec).` 
- 수신 측은 받는 즉시 바로 적용.
<img src=".\images\ReckoningNDelay.gif">
<!--![ReckoningNDelay.gif](images\ReckoningNDelay.gif)-->
<img src=".\images\plot_RD.png">
<!--![plot_RD.png](images\plot_RD.png)->

입력 쪽 딜레이가 발생하였지만, 차이가 눈에 띄게 줄은 것을 확인할 수 있다.


### 4.3 동기화 적용 후 실제 조작.
<img src=".\images\FreeMove.gif">
<!--![FreeMove.gif](images\FreeMove.gif)-->

30msec 정도의 딜레이를 적용했지만 키보드 조작 입력(좌하단)에 대한 지연은 체감상 크지 않았다. 만약 지연시간 동안 준비 동작 동작을 출력하여 지연을 감춘다면 유저가 체감하는 지연시간은 0에 가까울 것이다.

### 4.4 생각해볼 부분

#### Ⅰ 어떤 게임에 사용할 수 있을까
제한된 인원으로 특정 방(룸) 안에서 게임이 진행되며, 선입력 동안 보여줄 애니메이션이 있는 게임 혹은 동작에 적용하기 좋을 것이다. 매칭을 통해 진행하는 퍼즐, 캐주얼 슈팅 게임 등에 적용시킬 수 있을 것이라 생각한다.

#### Ⅱ 반대로 어떤 게임에는 사용하기 힘들까

30msec의 지연이 체감이 적다고 해서 지연이 전혀 느껴지지 않는 건 아니다. 따라서 FPS 같이 속도감이 중요한 게임의 경우, <U>매 조작에 대한 딜레이가 존재하는 것은 유저들에게 큰 불편을 줄 수 있다</U>. 

이 경우 차라리 클라 쪽에서 선 동작을 하며 서버에 보내고, 추후  결과를 전송받아 오차가 있다면 되돌리기를 하는 방식을 선택하는 것이 전반적인 조작감 향상에 좋을 것이라고 생각한다.


#### Ⅲ 해당 프로젝트는 지연시간을 정했는데 실제에서는?

실제 환경에서는 게임 시작 이전 로딩 환경에서 미리 지연시간\(tts\) 값을 구하고, 이후 점차 통신하면서 갱신하는 방법을 사용하는 게 좋을 것이다. 


